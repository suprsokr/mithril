package cmd

import (
	"fmt"
	"os"
	"os/exec"
	"path/filepath"
	"regexp"
	"strings"
)

// writeServerConfigs copies the .conf.dist files from the Docker image and
// patches only the settings that Mithril needs to override.  This ensures that
// every TrinityCore default is preserved and avoids "Missing name …" warnings.
func writeServerConfigs(cfg *Config) error {
	etcDir := filepath.Join(cfg.MithrilDir, "etc")
	if err := os.MkdirAll(etcDir, 0755); err != nil {
		return err
	}

	// Extract dist configs from the Docker image.
	for _, name := range []string{"worldserver.conf.dist", "authserver.conf.dist"} {
		dst := filepath.Join(etcDir, name)
		if fileExists(dst) {
			continue
		}
		cmd := exec.Command("docker", "run", "--rm", "mithril-server:latest",
			"cat", "/opt/trinitycore/etc/"+name)
		out, err := cmd.Output()
		if err != nil {
			return fmt.Errorf("failed to extract %s from image: %w", name, err)
		}
		if err := os.WriteFile(dst, out, 0644); err != nil {
			return err
		}
	}

	// Generate worldserver.conf by patching the dist.
	if err := generateConf(
		filepath.Join(etcDir, "worldserver.conf.dist"),
		filepath.Join(etcDir, "worldserver.conf"),
		worldserverOverrides(cfg),
	); err != nil {
		return fmt.Errorf("failed to write worldserver.conf: %w", err)
	}

	// Generate authserver.conf by patching the dist.
	if err := generateConf(
		filepath.Join(etcDir, "authserver.conf.dist"),
		filepath.Join(etcDir, "authserver.conf"),
		authserverOverrides(cfg),
	); err != nil {
		return fmt.Errorf("failed to write authserver.conf: %w", err)
	}

	return nil
}

// worldserverOverrides returns the key=value pairs that Mithril needs to
// change from the worldserver.conf.dist defaults.
func worldserverOverrides(cfg *Config) map[string]string {
	return map[string]string{
		"DataDir":                 `"/opt/trinitycore/data"`,
		"LogsDir":                `"/opt/trinitycore/log"`,
		"SourceDirectory":        `"/opt/trinitycore"`,
		"LoginDatabaseInfo":      fmt.Sprintf(`"127.0.0.1;3306;%s;%s;auth"`, cfg.MySQLUser, cfg.MySQLPassword),
		"WorldDatabaseInfo":      fmt.Sprintf(`"127.0.0.1;3306;%s;%s;world"`, cfg.MySQLUser, cfg.MySQLPassword),
		"CharacterDatabaseInfo":  fmt.Sprintf(`"127.0.0.1;3306;%s;%s;characters"`, cfg.MySQLUser, cfg.MySQLPassword),
		"Updates.EnableDatabases": "15",
		"PlayerLimit":            "100",
		"SOAP.IP":                `"0.0.0.0"`,
	}
}

// authserverOverrides returns the key=value pairs that Mithril needs to
// change from the authserver.conf.dist defaults.
func authserverOverrides(cfg *Config) map[string]string {
	return map[string]string{
		"LoginDatabaseInfo":       fmt.Sprintf(`"127.0.0.1;3306;%s;%s;auth"`, cfg.MySQLUser, cfg.MySQLPassword),
		"Updates.EnableDatabases": "1",
		"SourceDirectory":         `"/opt/trinitycore"`,
		"LogsDir":                 `"/opt/trinitycore/log"`,
	}
}

// generateConf reads a .conf.dist file and writes a .conf file with the given
// overrides applied.  Each override replaces the first matching "Key = …" line
// in the dist file.  A header comment is prepended so users know the file is
// generated.
func generateConf(distPath, confPath string, overrides map[string]string) error {
	data, err := os.ReadFile(distPath)
	if err != nil {
		return err
	}

	content := string(data)

	// Apply each override by replacing the matching line.
	for key, value := range overrides {
		// Match lines like:  Key = whatever   (with optional surrounding whitespace)
		pattern := regexp.MustCompile(`(?m)^(` + regexp.QuoteMeta(key) + `)\s*=\s*.*$`)
		if pattern.MatchString(content) {
			content = pattern.ReplaceAllString(content, key+" = "+value)
		} else {
			// Key not found in dist — append it at the end.
			content += "\n" + key + " = " + value + "\n"
		}
	}

	// Prepend a header so users know this file is generated.
	header := strings.Join([]string{
		"#",
		"# Generated by Mithril — edits are preserved unless you re-run 'mithril init'.",
		"# Based on " + filepath.Base(distPath),
		"#",
		"",
	}, "\n")

	return os.WriteFile(confPath, []byte(header+content), 0644)
}
